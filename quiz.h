/*
 * quiz.h
 * This file contains all the actual quizzes- plus the quiz item object.
 * Author: Paul Clarke
 *
 */

#ifndef __QUIZ_H_INCLUDED__
#define __QUIZ_H_INCLUDED__


#include "theory.h"
#include "synth1.h"
#include <vector>
#include <string>

std::vector<int> *randints(int start, int stop);

typedef struct ChordQItem {
    std::vector<Note> notevec;
    Key key;
    std::string suffix;
} ChordQItem;

int max_mn(std::vector<ChordQItem> chords);
int min_mn(std::vector<ChordQItem> chords);

class Quiz
{
public:
    Quiz(NoteSynth *s) : synth(s) {}
    virtual void begin() {}
    virtual int next_round() {}
protected:
    NoteSynth* synth;
};

class SingleQuiz : public Quiz
{
public:
    SingleQuiz(NoteSynth *s) : Quiz(s) {}
    virtual void begin() {}
    virtual int next_round();
protected:
    virtual ChordQItem get_item() {}
};

class Majmin7Quiz : public SingleQuiz
{
public:
    Majmin7Quiz(NoteSynth *s) : SingleQuiz(s) {}
    void begin() {}
protected:
    ChordQItem get_item();
};

/*
class MultiQuiz : public Quiz
{
    MultiQuiz(NoteSynth s) : Quiz(s) {}
    virtual void begin() {}
    virtual int next_round();
protected:
    virtual std::vector<ChordQItem> get_item() {}
};
*/

/* transpositions: generates all possible intervals by which to transpose a key
   such that the tranposition doesn't shift notes up or down by more than
   [uprange, downrange] semitones, and it doesn't add more flats or sharps
   to the key signature than [flat_limit, sharp_limit]. Includes the zero
   interval, SN(0, 0).*/
std::vector<s_note> transpositions(int up_range, int down_range, int flat_limit, int sharp_limit);

/* transpose_q: Transpose a chord or chords. Generator for other quizzes.

   Given a chord in the key k, generate a ChordQItem of that chord transposed to
   a random key in the same mode, and put somewhere in the range of midi notes
   [min_mn, max_mn]. The chord will be transposed to a key with a maximum of
   flatsharp_limit flats or sharps(if flatsharp_limit is negative,
   Key::get_flatsharp_limit() will be used). The name of the QItem will be
   generated by a given suffix appended to the key name. If show_lowest is true,
   then the value of the lowest note will be appended to this name. */
std::vector<ChordQItem> transpose_q(std::vector<ChordQItem> chords, int lower, int upper,
                       int min_sharps, int max_sharps, bool show_lowest=true);

/* triad in a random key and inversion */
ChordQItem major_triad_quiz();
/* root positioion major and minor seventh chords */
ChordQItem quiz_root_pos_majmin_7ths();

#endif
